---
layout: post
date:   2010-09-09 11:19:00 +0100
author: wizillo
categories: hacking tales_of_vesperia
---

A falta de escribir sobre los formatos de archivos de empaquetado y el script, voy a comentar lo que voy a hacer hoy:

Una de las cosas más peliagudas de la traducción va a ser la edición gráfica. Actualmente lo más importante es la edición de la fuente, y es lo que voy a intentar solucionar ASAP.

El paquete UI.svo (presumiblemente User Interface) contiene lo que son supuestamente las texturas que componen la fuente y otras imágenes como menús e imágenes de objetos.

La fuente presumiblemente está compuesta por los siguientes archivos: `FONTTEX00.TX(M|V)-FONTTEX16.TX(M|V)` 4MB cada uno (512x512x16). Los archivos con texturas están compuestos por dos archivos: TXM y TXV. TX posiblemente venga de TeXture. V igual de Vector o de Values. Y la M ni idea (quizá Modifiers).

En cualquier caso el TXM contiene información sobre la textura y el TXV los datos de la textura en raw.

Sobre el offset 0×60 o 0×64 (dependiendo) hay un entero de 32 bits big endian que contiene información sobre la textura almacenada. Si no me equivoco corresponde al enum D3DDECLTYPE que básicamente empaqueta información sobre el formato, el endian, si está tileado, el swizzling de colores (creo) etc.

Aquí un par de resultados que extraje con una utilidad que hice:

{% highlight text %}
File: 18280186 : cook_beefbowl
Format: 6
Endian: 2
Tiled: 1
numForm: 0
signXYZW: 0, 0, 0, 0
swizzXYZW: 2, 1, 0, 3 (b, g, r, a)

File: 1A200154 : fonttex01
Format: 20
Endian: 1
Tiled: 1
numForm: 0
signXYZW: 0, 0, 0, 0
swizzXYZW: 0, 1, 2, 3

GPUTEXTUREFORMAT_8_8_8_8   = 6,
GPUTEXTUREFORMAT_DXT4_5    = 20,
{% endhighlight %}

Aquí tenemos una imagen que está guardada en BGRA y sin comprimir (cook_beefbowl). Y otra, la de la fuente, que usa DXT4_5.

Además de la compresión de la textura, los pixeles están almacenados desordenados (supuestamente), lo que se llama swizzling para maximizar la caché de la GPU de la 360 a la hora de renderizar polígonos y acceder a mipmaps. También creo que igual almacena en la misma imagen un mipmap. En principio y supuestamente el cook_beefbowl no debería tener mipmaps, pero no estoy 100% seguro.

Al extraer usando tiles de 32×32, he sacado esta imagen:

![COOK_BEEFBOWL.png](/img/2010/09/COOK_BEEFBOWL.png)

Los colores están bien, así que el formato 8_8_8_8 es correcto, pero obviamente los pixeles están desordenados.

Luego explicaré cómo voy a intentar “adivinar” el ordenado de los pixeles ahora que tengo la JTAG.

